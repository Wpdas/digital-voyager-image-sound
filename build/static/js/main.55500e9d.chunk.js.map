{"version":3,"sources":["../../src/constants.ts","../../../src/core/binaryToDecimal.ts","../../../../src/loaders/utils/Header.ts","../../../src/core/decimalToBinary.ts","helpers/secondsToMMSS/index.ts","contexts/Log.tsx","components/InfoBar/styles.ts","components/InfoBar/index.tsx","components/FileInput/index.ts","components/Audio/styles.ts","components/Audio/index.tsx","components/VisualizerCanvas/styles.ts","components/VisualizerCanvas/index.tsx","components/StageCanvas/styles.ts","components/StageCanvas/index.tsx","containers/Main/reducer.ts","containers/Main/styles.ts","containers/Main/index.tsx","App.tsx","index.tsx","../../../src/core/uint8ToNumber.ts","../../../../src/loaders/utils/EncodedOutput.ts","components/EncodeImageStatus/styles.ts","../../../src/core/sliceTextInChunks.ts","../../../src/core/numberToUint8.ts","../../../src/core/bppToHex.ts","../../../src/core/asciiToBytes.ts","../../../src/core/bytesToAscii.ts","../../../src/loaders/ASCIIText.ts","../../../src/core/hexToBpp.ts","../../../src/core/encodeBitmapPerPixel.ts","../../../src/loaders/Bitmap2bitspp.ts","../../../src/loaders/Bitmap4bitspp.ts","../../../src/loaders/Bitmap1bitpp.ts","../../../src/loaders/DecimalNumber.ts","../../../src/helpers/getLoaderByTypeId.ts","../../../src/core/decodeBitmapPerPixel.ts","helpers/saveFile/index.ts","helpers/processSound/index.ts","../../../src/helpers/getTypeIdFromBuffer.ts","../../../src/helpers/getBitmapHeaderInfo.ts","../../../src/loaders/Bitmap24bitsTrueColor.ts","../../../src/loaders/Bitmap8bitspp.ts","../../../src/core/getBytesFromBuffer.ts","helpers/fileToBuffer/index.ts","components/EncodeImageStatus/index.tsx","../../../src/core/writeSampleBytes.ts","helpers/uint8arrayToArray/index.ts","helpers/imageToBitmap/index.ts","assets/images/image_preview.jpg","assets/svgs/app_icon.svg"],"names":["DEFAULT_BITS_DEPTH","bitsSquence","numberValue","secondsToMMSS","secondsValue","hours","Math","floor","minutes","seconds","toString","padStart","defaultValue","icon","text","currentTime","duration","setText","Error","setIcon","setTime","LogContext","createContext","LogProvider","children","useState","setCurrentTime","setDuration","valueBody","Provider","value","Container","styled","div","TextWrapperLeft","TextWrapperRight","InfoBar","useContext","iconSize","color","style","fontSize","margin","FileInput","input","attrs","type","accept","AudioContainer","audio","Audio","audioRef","onTimeUpdate","ref","onDurationChange","Canvas","canvas","VisualizerCanvas","canvasRef","width","height","StageCanvas","initialState","imageFileOpen","imageFile","soundFileOpen","soundFile","fileTypeId","NaN","soundFileBuffer","bitmapHeader","isDecoding","currentSoundFileDecoded","MainReducer","state","action","payload","Content","Menu","AppLogo","img","Title","Description","Info","MainStage","StageWrapper","Main","React","memo","useReducer","dispatch","log","visualizerCanvasRef","useRef","stageCanvasRef","soundFileInputRef","imageFileInputRef","useEffect","onDecodeFinished","handlerOnSelectSoundFile","a","files","current","length","fileToBuffer","currentSoundFileBuffer","getTypeIdFromBuffer","bitmapTypeIds","indexOf","getBitmapHeaderInfo","clearStage","Icon","SIZE_LARGE","title","description","noFileOpenInfo","fileReadContainer","className","Group","align","Alignment","LEFT","src","logo","Heading","Divider","onClick","setTimeout","click","RIGHT","processSound","saveDecodedFile","EncodeImageStatus","file","onChange","imageFiles","event","round","currentTarget","App","ReactDOM","render","StrictMode","document","getElementById","Paragraph","p","FileStatus","ImageDetailWrapper","ImageDetail","PreviewImage","bytes","BMP_CONTENT_TYPE","WAV_CONTENT_TYPE","saveFile","buffer","filename","contentType","createElement","blob","Blob","Uint8Array","byteOffset","href","window","URL","createObjectURL","download","stageContext","canvasWidth","canvasHeight","imageData","data","currentFileBytes","currentFileSampleData","previousAnimationId","handlerOnDecodeFinished","handler","clearRect","initStageProcess","stageCanvas","getContext","CanvasRenderingContext2D","getImageData","initAudioProcess","visualizerCanvas","bufferLength","analyser","frequencyBinCount","dataArray","WIDTH","HEIGHT","visualizerContext","cancelAnimationFrame","play","renderFrame","requestAnimationFrame","getByteTimeDomainData","percPlayed","readBytes","ceil","finalAdd","diff","isNaN","loader","decodeChunk","totalSamplesSize","bytesChunk","putImageData","draw","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","y","moveTo","lineTo","stroke","audioContext","source","fileReader","FileReader","processInitialized","AudioContext","createMediaElementSource","createAnalyser","connect","destination","fftSize","onended","onload","getBytesFromBuffer","Buffer","from","result","getLoaderByTypeId","getSampleData","readAsArrayBuffer","header","getHeaderTypeId","decode","Promise","resolve","arrayBuffer","handlerEncodeImage","bitmapLoaderId","companionFileName","imageToBitmap","fileBuffer","bitmapLoader","encodedData","encode","writeSampleBytes","uint8ArrayToArray","encodedBuffer","name","marginLeft","previewImage","float","justifyContent","loadersTypeId","BITMAP_1BIT_PP","BITMAP_2BITS_PP","BITMAP_4BITS_PP","BITMAP_8BITS_PP","BITMAP","uint8","output","forEach","byte","push","imageBuffer","Jimp","read","image","QBGR","bitmap","readUInt8","bmp","module","exports"],"mappings":"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","file":"static/js/main.55500e9d.chunk.js","sourcesContent":["/**\n * Project bits depth.\n */\nexport const DEFAULT_BITS_DEPTH = 8;\n/**\n * WAV Header bytes size\n */\nexport const WAV_HEADER_BYTES_SIZE = 44;\n/**\n * Typeid uses 8 bits of information\n */\nexport const TYPE_ID_BITS_SIZE = 8;\n/**\n * Typeid uses 1 byte of information\n */\nexport const TYPE_ID_BYTE_SIZE = 1;\n/**\n * Unitary value for one SampleByte (Algorithm)\n */\nexport const SAMPLE_BYTE = 0.0078431373;\n/**\n * Audio sample rate\n */\nexport const SAMPLE_RATE = 44100; // 384000 Voyager Disc\n/**\n * Loaders types\n */\nexport const loadersTypeId = {\n    DECIMAL_NUMBER: 0,\n    ASCII_TEXT: 1,\n    BITMAP: 2,\n    BITMAP_1BIT_PP: 3,\n    BITMAP_2BITS_PP: 4,\n    BITMAP_4BITS_PP: 5,\n    BITMAP_8BITS_PP: 6,\n    VIDEO_4BITS_PP: 7,\n};\n/**\n * Array containing Bitmap loaders ids\n */\nexport const bitmapTypeIds = [\n    loadersTypeId.BITMAP,\n    loadersTypeId.BITMAP_1BIT_PP,\n    loadersTypeId.BITMAP_2BITS_PP,\n    loadersTypeId.BITMAP_4BITS_PP,\n    loadersTypeId.BITMAP_8BITS_PP,\n];\n//# sourceMappingURL=constants.js.map","/**\n * Converts bits containing decimal number data to decimal itself\n * @param {string} bitsSquence bits of a decimal number\n * @returns {number} decimal number\n */\nconst binaryToDecimal = (bitsSquence) => {\n    return parseInt(bitsSquence, 2);\n};\nexport default binaryToDecimal;\n//# sourceMappingURL=binaryToDecimal.js.map","class Header {\n    /**\n     * Create the Header content\n     * @param {number} typeId Content type. Should be specified so that, the Reader\n     * will be able to know how to handle with the bits. This is the most basic\n     * information needed. More can be passed using the additional parameter.\n     * @param {Array<string>} additionalParams Pass addional header parameters to be stored.\n     * This can be used to store data like width, height, etc.\n     */\n    constructor(typeId, additionalParams) {\n        this.additionalParams = [];\n        /**\n         * Get the Header bytes\n         */\n        this.getHeaderBytes = () => {\n            const headerBytes = [this.typeId];\n            return headerBytes.concat(this.additionalParams);\n        };\n        /**\n         * Get typeId data from Header.\n         * @return typeId data in decimal number format. e.g.: 29\n         */\n        this.getHeaderTypeId = () => this.typeId;\n        /**\n         * Add bytes to the header\n         * @param Bytes Bytes to be stored on Header as a additional parameter. Must be a multiple of 8 bits\n         */\n        this.addBytes = (bytes) => {\n            this.additionalParams = this.additionalParams.concat(bytes);\n        };\n        this.typeId = typeId;\n        if (additionalParams != null) {\n            this.additionalParams.concat(additionalParams);\n        }\n    }\n}\nexport default Header;\n//# sourceMappingURL=Header.js.map","/**\n * Converts decimal number to bits (multiple of 8 bits)\n *\n * Example of usage:\n * DecimalNumber.encode(2, 720); Returns \"0000001011010000\"\n *\n * You can limit the bytes depth by informing the amount on bytesDepth parameter. If not informed,\n * it will use only the necessary amount of bytes (multiple of 8 bits);\n *\n * @param {number} numberValue decimal number value\n * @param {number} bitsDepth amount of bits (8 bits = 1 byte). Infinite if not informed.\n * @returns {string}\n */\nconst decimalToBinary = (numberValue, bitsDepth) => {\n    const bits = numberValue.toString(2);\n    const currentBitsSize = bits.length;\n    let nullBits = '';\n    // Limits the amount of bits\n    if (bitsDepth != null) {\n        // Bytes depth should support the numberValue bits\n        if (currentBitsSize > bitsDepth) {\n            throw new Error('Bytes depth is not enough to store the passed numberValue.');\n        }\n        nullBits = Array(bitsDepth - currentBitsSize)\n            .fill('0')\n            .join('');\n    }\n    else {\n        // Will auto adjust the necessary amount of bits to store data\n        const expectedBitsSize = Math.ceil(currentBitsSize / 8) * 8;\n        nullBits = Array(expectedBitsSize - currentBitsSize)\n            .fill('0')\n            .join('');\n    }\n    return nullBits + bits;\n};\nexport default decimalToBinary;\n//# sourceMappingURL=decimalToBinary.js.map","/**\n * Converts seconds to MM:SS format\n * @param secondsValue\n */\nconst secondsToMMSS = (secondsValue: number) => {\n  const hours = Math.floor(secondsValue / 60 / 60);\n  const minutes = Math.floor(secondsValue / 60) - hours * 60;\n  const seconds = secondsValue % 60;\n  return `${minutes.toString().padStart(2, '0')}:${seconds\n    .toString()\n    .padStart(2, '0')}`;\n};\n\nexport default secondsToMMSS;\n","import React, { createContext, useState } from 'react';\nimport { IconName } from '@blueprintjs/core';\nimport secondsToMMSS from 'helpers/secondsToMMSS';\n\ninterface LogProviderValue {\n  readonly icon: IconName;\n  readonly text: string;\n  readonly currentTime: string;\n  readonly duration: string;\n  readonly setText: (text: string) => void;\n  readonly setIcon: (iconName: IconName) => void;\n  readonly setTime: (currentTime: number, duration: number) => void;\n}\n\nconst defaultValue: LogProviderValue = {\n  icon: 'cube',\n  text: 'Waiting file to be open...',\n  currentTime: '00:00',\n  duration: '00:00',\n  setText: () => new Error('setText should be defined'),\n  setIcon: () => new Error('setIcon should be defined'),\n  setTime: () => new Error('setTime should be defined'),\n};\n\nconst LogContext = createContext(defaultValue);\n\ninterface LogProviderProps {\n  children: React.ReactNode;\n}\n\nexport const LogProvider: React.FC<LogProviderProps> = ({\n  children,\n}: LogProviderProps) => {\n  const [icon, setIcon] = useState<IconName>('cube');\n  const [text, setText] = useState('Waiting file to be open');\n  const [currentTime, setCurrentTime] = useState('00:00');\n  const [duration, setDuration] = useState('00:00');\n  const valueBody: LogProviderValue = {\n    icon,\n    text,\n    currentTime,\n    duration,\n    setIcon,\n    setText,\n    setTime: (currentTime, duration) => {\n      setCurrentTime(secondsToMMSS(currentTime));\n      setDuration(secondsToMMSS(duration));\n    },\n  };\n\n  return (\n    <LogContext.Provider value={valueBody}>{children}</LogContext.Provider>\n  );\n};\n\nexport default LogContext;\n","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: flex;\n  justify-content: space-between;\n  background: #182128;\n  height: 25px;\n  width: 100%;\n`;\n\nexport const TextWrapperLeft = styled.div`\n  display: flex;\n  margin: 5px 6px 0 16px;\n`;\n\nexport const TextWrapperRight = styled.div`\n  display: flex;\n  margin: 5px 16px 0 6px;\n  text-align: right;\n`;\n","import React, { useContext } from 'react';\nimport { H6, Icon } from '@blueprintjs/core';\n\nimport LogContext from 'contexts/Log';\nimport { Container, TextWrapperLeft, TextWrapperRight } from './styles';\n\nexport default function InfoBar() {\n  const { icon, text, currentTime, duration } = useContext(LogContext);\n\n  return (\n    <Container>\n      <TextWrapperLeft>\n        <Icon icon={icon} iconSize={14} color=\"#f5f8fa\" />\n        <H6 style={{ color: '#f5f8fa', fontSize: 12, margin: '0 0 0 12px' }}>\n          {text}\n        </H6>\n      </TextWrapperLeft>\n      <TextWrapperRight>\n        <Icon icon=\"time\" iconSize={14} color=\"#f5f8fa\" />\n        <H6 style={{ color: '#f5f8fa', fontSize: 12, margin: '0 0 0 12px' }}>\n          {currentTime} / {duration}\n        </H6>\n      </TextWrapperRight>\n    </Container>\n  );\n}\n","import styled from 'styled-components';\n\ninterface FileProps {\n  accept: string;\n}\n\nconst FileInput = styled.input.attrs(({ accept }: FileProps) => ({\n  type: 'file',\n  accept,\n}))`\n  display: none;\n`;\n\nexport default FileInput;\n","import styled from 'styled-components';\n\nexport const AudioContainer = styled.audio`\n  display: none;\n`;\n","import React from 'react';\n\nimport { AudioContainer } from './styles';\n\ninterface AudioProps {\n  audioRef: React.RefObject<HTMLAudioElement> | null | undefined;\n  onTimeUpdate?: (\n    event?: React.SyntheticEvent<HTMLAudioElement, Event> | undefined\n  ) => void;\n}\n\nconst Audio: React.FC<AudioProps> = ({\n  audioRef,\n  onTimeUpdate,\n}: AudioProps) => {\n  return (\n    <AudioContainer\n      ref={audioRef}\n      onDurationChange={onTimeUpdate}\n      onTimeUpdate={onTimeUpdate}\n    />\n  );\n};\n\nexport default Audio;\n","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  /* background: #182128; */\n  /* border-top: 1px #f5f8fa50 solid; */\n`;\n\nexport const Canvas = styled.canvas`\n  background: #000;\n  transform: rotate(180deg);\n  border-top: 2px solid #000;\n`;\n","import React from 'react';\nimport { Container, Canvas } from './styles';\n\ninterface Props {\n  canvasRef: React.RefObject<HTMLCanvasElement> | null | undefined;\n  width: number;\n  height: number;\n}\n\nconst VisualizerCanvas: React.FC<Props> = ({\n  canvasRef,\n  width,\n  height,\n}: Props) => {\n  return (\n    <Container>\n      <Canvas ref={canvasRef} width={width} height={height} />\n    </Container>\n  );\n};\n\nexport default VisualizerCanvas;\n","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n`;\n\nexport const Canvas = styled.canvas`\n  background: #000000;\n`;\n","import React from 'react';\nimport { Container, Canvas } from './styles';\n\ninterface Props {\n  width: number;\n  height: number;\n  canvasRef: React.RefObject<HTMLCanvasElement> | null | undefined;\n}\n\nconst StageCanvas: React.FC<Props> = ({ canvasRef, width, height }: Props) => {\n  return (\n    <Container>\n      <Canvas ref={canvasRef} width={width} height={height} />\n    </Container>\n  );\n};\n\nexport default StageCanvas;\n","import { BitmapWavHeader } from 'voyager-edsound/lib/helpers';\n\nexport const RESET_ACTION = 'RESET_ACTION';\nexport const AUDIO_FILE_OPENED_ACTION = 'AUDIO_FILE_OPENED_ACTION';\nexport const IMAGE_FILE_OPENED_ACTION = 'IMAGE_FILE_OPENED_ACTION';\nexport const DECODING_STARTED_ACTION = 'DECODING_STARTED_ACTION';\nexport const DECODING_FINISHED_ACTION = 'DECODING_FINISHED';\n\ntype ActionTypes =\n  | typeof RESET_ACTION\n  | typeof AUDIO_FILE_OPENED_ACTION\n  | typeof IMAGE_FILE_OPENED_ACTION\n  | typeof DECODING_STARTED_ACTION\n  | typeof DECODING_FINISHED_ACTION;\n\ninterface State {\n  imageFileOpen?: boolean;\n  imageFile?: File | null;\n  soundFileOpen?: boolean;\n  soundFile?: File | null;\n  fileTypeId?: number;\n  soundFileBuffer?: Buffer | null;\n  bitmapHeader?: BitmapWavHeader | null;\n  isDecoding?: boolean;\n  currentSoundFileDecoded?: boolean;\n}\n\nexport const initialState: State = {\n  imageFileOpen: false,\n  imageFile: null,\n  soundFileOpen: false,\n  soundFile: null,\n  fileTypeId: NaN,\n  soundFileBuffer: null,\n  bitmapHeader: null,\n  isDecoding: false,\n  currentSoundFileDecoded: false,\n};\n\ninterface Action {\n  type: ActionTypes;\n  payload: State;\n}\n\nconst MainReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case RESET_ACTION:\n      return {\n        ...state,\n        ...action.payload,\n      } as State;\n    case AUDIO_FILE_OPENED_ACTION:\n      return {\n        ...state,\n        ...action.payload,\n      } as State;\n    case IMAGE_FILE_OPENED_ACTION:\n      return {\n        ...state,\n        ...action.payload,\n      } as State;\n    case DECODING_STARTED_ACTION:\n      return {\n        ...state,\n        ...action.payload,\n      } as State;\n    case DECODING_FINISHED_ACTION:\n      return {\n        ...state,\n        ...action.payload,\n      } as State;\n    default:\n      return state;\n  }\n};\n\nexport default MainReducer;\n","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n`;\n\nexport const Content = styled.div`\n  flex: 1;\n`;\n\nexport const Menu = styled.div`\n  user-select: none;\n`;\n\nexport const AppLogo = styled.img`\n  margin-right: 12px;\n`;\n\nexport const Title = styled.div`\n  color: #f5f8fa;\n`;\n\nexport const Description = styled.div`\n  color: #f5f8fa;\n`;\n\nexport const Info = styled.div`\n  margin-top: 32vh;\n  user-select: none;\n`;\n\nexport const MainStage = styled.div`\n  display: flex;\n  flex-direction: column;\n  /* height: 92%; */\n  height: calc(100% - 25px);\n  justify-content: center;\n`;\n\nexport const StageWrapper = styled.div`\n  background: #000;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  min-width: 753px;\n  min-height: 446px;\n  align-self: center;\n  border: 1px solid #000;\n`;\n","import React, { useContext, useRef, useReducer, useEffect } from 'react';\nimport {\n  Button,\n  Navbar,\n  Alignment,\n  NonIdealState,\n  Icon,\n} from '@blueprintjs/core';\n\nimport {\n  BitmapWavHeader,\n  getBitmapHeaderInfo,\n  getTypeIdFromBuffer,\n} from 'voyager-edsound/lib/helpers';\nimport { bitmapTypeIds } from 'voyager-edsound/lib/constants';\n\nimport LogContext from 'contexts/Log';\n\nimport {\n  processSound,\n  onDecodeFinished,\n  clearStage,\n  saveDecodedFile,\n} from 'helpers/processSound';\nimport fileToBuffer from 'helpers/fileToBuffer';\n\nimport InfoBar from 'components/InfoBar';\nimport FileInput from 'components/FileInput';\nimport Audio from 'components/Audio';\nimport VisualizerCanvas from 'components/VisualizerCanvas';\nimport StageCanvas from 'components/StageCanvas';\nimport EncodeImageStatus from 'components/EncodeImageStatus';\n\nimport MainReducer, {\n  initialState,\n  AUDIO_FILE_OPENED_ACTION,\n  DECODING_FINISHED_ACTION,\n  DECODING_STARTED_ACTION,\n  IMAGE_FILE_OPENED_ACTION,\n  RESET_ACTION,\n} from './reducer';\n\nimport {\n  Container,\n  Content,\n  Menu,\n  Title,\n  Description,\n  Info,\n  MainStage,\n  StageWrapper,\n  AppLogo,\n} from './styles';\n\nimport logo from '../../assets/svgs/app_icon.svg';\n\nconst MIN_VISUALIZER_WIDTH = 753;\n\nconst Main = React.memo(() => {\n  const [state, dispatch] = useReducer(MainReducer, initialState);\n  const {\n    soundFileOpen,\n    soundFile,\n    imageFileOpen,\n    imageFile,\n    fileTypeId,\n    soundFileBuffer,\n    bitmapHeader,\n    isDecoding,\n    currentSoundFileDecoded,\n  } = state;\n\n  const log = useContext(LogContext);\n  const visualizerCanvasRef = useRef<HTMLCanvasElement>(null);\n  const stageCanvasRef = useRef<HTMLCanvasElement>(null);\n  const audioRef = useRef<HTMLAudioElement>(null);\n  const soundFileInputRef = useRef<HTMLInputElement>(null);\n  const imageFileInputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    onDecodeFinished(() => {\n      // Update state\n      dispatch({\n        type: DECODING_FINISHED_ACTION,\n        payload: { isDecoding: false, currentSoundFileDecoded: true },\n      });\n      log.setIcon('tick');\n      log.setText('Decoding process completed!');\n    });\n  }, [log]);\n\n  // On open sound file to be decoded to image\n  const handlerOpenSoundFile = () => {\n    // If Encode image component is activated\n    if (imageFileOpen) {\n      // Update state\n      dispatch({\n        type: RESET_ACTION,\n        payload: {\n          soundFileOpen: false,\n          imageFileOpen: false,\n          imageFile: null,\n          currentSoundFileDecoded: false,\n        },\n      });\n    }\n\n    setTimeout(() => {\n      soundFileInputRef.current?.click();\n    }, 500);\n  };\n\n  // On open image file to be encoded to sound\n  const handlerOpenImageFile = () => {\n    imageFileInputRef.current?.click();\n  };\n\n  // On select sound file\n  const handlerOnSelectSoundFile = async () => {\n    const files = soundFileInputRef.current?.files;\n    let fileTypeId: number;\n    let bitmapHeader: BitmapWavHeader | null = null;\n\n    if (files && files.length) {\n      const currentSoundFileBuffer = await fileToBuffer(files[0]);\n      fileTypeId = getTypeIdFromBuffer(currentSoundFileBuffer);\n\n      // If file has Bitmap typeId\n      if (bitmapTypeIds.indexOf(fileTypeId) !== -1) {\n        bitmapHeader = getBitmapHeaderInfo(currentSoundFileBuffer);\n      }\n\n      // Update state\n      dispatch({\n        type: AUDIO_FILE_OPENED_ACTION,\n        payload: {\n          fileTypeId,\n          soundFileBuffer: currentSoundFileBuffer,\n          bitmapHeader,\n          soundFileOpen: true,\n          soundFile: files[0],\n          imageFileOpen: false,\n          imageFile: null,\n          currentSoundFileDecoded: false,\n        },\n      });\n\n      // Clear stage canvas\n      clearStage();\n\n      log.setIcon('tick');\n      log.setText('File opened and ready to be decoded');\n    }\n  };\n\n  // On select image file\n  const handlerOnSelectImageFile = () => {\n    const imageFiles = imageFileInputRef.current?.files;\n    if (imageFiles && imageFiles.length) {\n      // Update state\n      dispatch({\n        type: IMAGE_FILE_OPENED_ACTION,\n        payload: {\n          soundFileBuffer: null,\n          soundFileOpen: false,\n          soundFile: null,\n          imageFileOpen: true,\n          imageFile: imageFiles[0],\n          currentSoundFileDecoded: false,\n        },\n      });\n\n      log.setIcon('tick');\n      log.setText(\n        'Image file opened. Select the Bits depth you want to use to encode it.'\n      );\n    }\n  };\n\n  const handlerPlayAndDecode = () => {\n    if (\n      visualizerCanvasRef.current &&\n      stageCanvasRef.current &&\n      audioRef.current &&\n      soundFile\n    ) {\n      processSound(\n        visualizerCanvasRef.current,\n        stageCanvasRef.current,\n        audioRef.current,\n        soundFile\n      );\n\n      // Update state\n      dispatch({\n        type: DECODING_STARTED_ACTION,\n        payload: { isDecoding: true },\n      });\n      log.setIcon('full-stacked-chart');\n      log.setText('Deconding...');\n    }\n  };\n\n  const handlerOnClickSaveDecodedFile = () => {\n    if (soundFileBuffer != null && fileTypeId != null) {\n      saveDecodedFile();\n\n      log.setIcon('tick');\n      log.setText('Done');\n    }\n  };\n\n  const handlerOnTimeUpdate = (\n    event: React.SyntheticEvent<HTMLAudioElement, Event> | undefined\n  ) => {\n    if (event != null) {\n      log.setTime(\n        Math.round(event.currentTarget.currentTime),\n        Math.round(event.currentTarget.duration)\n      );\n    }\n  };\n\n  const icon = (\n    <Icon\n      icon=\"folder-open\"\n      iconSize={Icon.SIZE_LARGE * 3}\n      color=\"rgba(167,182,194,.6)\"\n    />\n  );\n  const title = <Title>No file opened</Title>;\n  const description = (\n    <Description>\n      Open a .wav file generated by this app and decode it to\n      <br />\n      get the image stored on its samples or open an image file you want to\n      encode as sound.\n    </Description>\n  );\n\n  const noFileOpenInfo = (\n    <Info>\n      <NonIdealState icon={icon} title={title} description={description} />\n    </Info>\n  );\n\n  const fileReadContainer = (\n    <MainStage>\n      <StageWrapper>\n        <VisualizerCanvas\n          canvasRef={visualizerCanvasRef}\n          width={\n            bitmapHeader != null && bitmapHeader?.width >= MIN_VISUALIZER_WIDTH\n              ? bitmapHeader?.width\n              : MIN_VISUALIZER_WIDTH\n          }\n          height={100}\n        />\n        <StageCanvas\n          canvasRef={stageCanvasRef}\n          width={bitmapHeader?.width || 0}\n          height={bitmapHeader?.height || 0}\n        />\n      </StageWrapper>\n    </MainStage>\n  );\n\n  return (\n    <>\n      <Container>\n        <Content>\n          <Menu>\n            <Navbar className=\"bp3-dark\">\n              <Navbar.Group align={Alignment.LEFT}>\n                <AppLogo src={logo} width={34} />\n                <Navbar.Heading>Digital Voyager Image Sound</Navbar.Heading>\n                <Navbar.Divider />\n                {!isDecoding ? (\n                  <>\n                    <Button\n                      className=\"bp3-minimal\"\n                      icon=\"document\"\n                      text=\"Decode Sound File\"\n                      onClick={handlerOpenSoundFile}\n                    />\n                    <Navbar.Divider />\n                    <Button\n                      className=\"bp3-minimal\"\n                      icon=\"document\"\n                      text=\"Encode Image File\"\n                      onClick={handlerOpenImageFile}\n                    />\n                  </>\n                ) : null}\n              </Navbar.Group>\n              <Navbar.Group align={Alignment.RIGHT}>\n                {soundFileOpen && !isDecoding ? (\n                  <Button\n                    className=\"bp3-minimal\"\n                    icon=\"full-stacked-chart\"\n                    text=\"Play and Decode\"\n                    onClick={handlerPlayAndDecode}\n                  />\n                ) : null}\n                {soundFileOpen && !isDecoding && currentSoundFileDecoded ? (\n                  <Button\n                    className=\"bp3-minimal\"\n                    icon=\"archive\"\n                    text=\"Save Decoded File\"\n                    onClick={handlerOnClickSaveDecodedFile}\n                  />\n                ) : null}\n              </Navbar.Group>\n            </Navbar>\n          </Menu>\n          {soundFileOpen && !imageFileOpen ? fileReadContainer : null}\n          {imageFileOpen && !soundFileOpen && imageFile ? (\n            <EncodeImageStatus file={imageFile} />\n          ) : null}\n          {!imageFileOpen && !soundFileBuffer && !imageFile\n            ? noFileOpenInfo\n            : null}\n          <FileInput\n            ref={soundFileInputRef}\n            accept=\".wav\"\n            onChange={handlerOnSelectSoundFile}\n          />\n          <FileInput\n            ref={imageFileInputRef}\n            accept=\"image/*\"\n            onChange={handlerOnSelectImageFile}\n          />\n          <Audio audioRef={audioRef} onTimeUpdate={handlerOnTimeUpdate} />\n        </Content>\n        <InfoBar />\n      </Container>\n    </>\n  );\n});\n\nexport default Main;\n","import React from 'react';\nimport { LogProvider } from 'contexts/Log';\nimport Main from 'containers/Main';\n\nfunction App() {\n  return (\n    <LogProvider>\n      <Main />\n    </LogProvider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Blueprint dependencies\nimport 'normalize.css/normalize.css';\nimport '@blueprintjs/icons/lib/css/blueprint-icons.css';\nimport '@blueprintjs/core/lib/css/blueprint.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","import decimalToBinary from './decimalToBinary';\nimport binaryToDecimal from './binaryToDecimal';\n/**\n * Converts Uint8 number sequence to int number. This is the way of having the number encoded by\n * numberToUint8 module.\n *\n * Examples:\n * give [1], it'll return 1\n * give [255], it'll return 255\n * give [1, 0], it'll return 256\n * give [253, 232], it'll return 65000\n *\n * @param uint8Sequence Uint8 sequence to be converted to int number\n */\nconst uint8ToNumber = (uint8Sequence) => {\n    const bitsArray = uint8Sequence.map((decimalValue) => decimalToBinary(decimalValue));\n    return binaryToDecimal(bitsArray.join(''));\n};\nexport default uint8ToNumber;\n//# sourceMappingURL=uint8ToNumber.js.map","class EncodedOutput {\n    /**\n     * Creates an output with the final bits information\n     * @param header The Loader Header\n     * @param byteArray The ouput bits\n     */\n    constructor(header, byteArray) {\n        this.finalBytes = header.getHeaderBytes().concat(byteArray);\n    }\n    /**\n     * Output bytes\n     */\n    get bytes() {\n        const output = new Uint8Array(this.finalBytes);\n        return output;\n    }\n}\nexport default EncodedOutput;\n//# sourceMappingURL=EncodedOutput.js.map","import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: flex;\n  margin-top: 18vh;\n  margin-left: auto;\n  margin-right: auto;\n  min-width: 800px;\n  max-width: 850px;\n  height: 400px;\n  flex-direction: column;\n`;\n\nexport const Paragraph = styled.p`\n  color: #f5f8fa;\n`;\n\nexport const FileStatus = styled.div`\n  display: flex;\n  margin-bottom: 24px;\n`;\n\nexport const ImageDetailWrapper = styled.div`\n  display: flex;\n  justify-content: space-evenly;\n`;\n\nexport const ImageDetail = styled.p`\n  text-align: center;\n  color: #f5f8fa;\n  background: #182128;\n  width: 20%;\n  margin-bottom: 0;\n  padding: 16px 0;\n`;\n\nexport const PreviewImage = styled.img`\n  width: 100%;\n`;\n","/**\n * Slices string and returns a new array with the chunks.\n * @param text  String to be sliced\n * @param chunkLength Amount of chars per chunk\n * @param startText String to be added at the beginning of each chunk\n * @param fillEmptySlots Should fill the chunks that not have enough data to be filled?\n * @param emptySlotText Text used to fill the empty slots in case of fillEmptySlots param is true. This text will be\n * placed at the final.\n */\nconst sliceTextInChunks = (text, chunkLength = 8, startText = '', fillEmptySlots = false, emptySlotText = '0') => {\n    const chunks = [];\n    const size = text.length;\n    for (let i = 0; i < size; i += chunkLength) {\n        let chunk = startText + text.slice(i, i + chunkLength);\n        if (fillEmptySlots && chunk.length < chunkLength) {\n            const emptyRepresentationalData = Array(chunkLength - chunk.length)\n                .fill(emptySlotText)\n                .join('');\n            chunks.push(chunk + emptyRepresentationalData);\n        }\n        else {\n            chunks.push(chunk);\n        }\n    }\n    return chunks;\n};\nexport default sliceTextInChunks;\n//# sourceMappingURL=sliceTextInChunks.js.map","import decimalToBinary from './decimalToBinary';\nimport sliceTextInChunks from './sliceTextInChunks';\nimport binaryToDecimal from './binaryToDecimal';\nimport { DEFAULT_BITS_DEPTH } from '../constants';\n/**\n * Converts any number to Uint8 number.\n * 1 byte (8 bits) supports a total of 255 in decimal, this module will create the necessary amount of bits\n * and converts every sequence of 8 bits in decimal. An array will be returned containing the values.\n *\n * Examples:\n * give 1, it'll return [1]\n * give 255, it'll return [255]\n * give 256, it'll return [1, 0]\n * give 257, it'll return [1, 1]\n * give 65000, it'll return [253, 232]\n *\n * @param value Number to be converted\n * @param depth The uint8 array depth. Each depth is equal to 8 bits / 1 byte / 255 in decimal / 1 item into the array.\n * It will be adjusted to fit the desired depth, example:\n *\n * give numberToUint8(255, 2), it'll return [0, 255]\n */\nconst numberToUint8 = (value, depth) => {\n    const bits = decimalToBinary(value);\n    const bitsArray = sliceTextInChunks(bits, DEFAULT_BITS_DEPTH);\n    if (depth != null) {\n        // Error if bigger\n        if (bitsArray.length > depth) {\n            throw new Error('The value is too long to be stored');\n        }\n        // Adjust if not fit the desired depth\n        if (depth - bitsArray.length < depth) {\n            for (let i = 0; i < depth - bitsArray.length; i++) {\n                bitsArray.unshift('00000000');\n            }\n        }\n    }\n    return bitsArray.map((bitsSequence) => binaryToDecimal(bitsSequence));\n};\nexport default numberToUint8;\n//# sourceMappingURL=numberToUint8.js.map","import binaryToDecimal from './binaryToDecimal';\nconst MAX_HEX = 255;\n/**\n * Convert the decimal reference color to Hex Color\n * @param colorBitsFactor The factor of color in bits (previouly generated by hexToBpp())\n * @param maxBitsToStore Bits used to store the color data 2, 4, 8\n */\nconst bppToHex = (colorBitsFactor, maxBitsToStore) => {\n    const maxBits = Array(maxBitsToStore).fill('1').join('');\n    const bitsMaxSuportedValue = binaryToDecimal(maxBits);\n    const avaragePerColorFactor = MAX_HEX / bitsMaxSuportedValue;\n    return avaragePerColorFactor * colorBitsFactor;\n};\nexport default bppToHex;\n//# sourceMappingURL=bppToHex.js.map","/**\n * Converts ASCII-UTF8 text to bytes\n * @param text ASCII text format (UTF8)\n */\nconst asciiToBytes = (text) => {\n    const bytes = [];\n    for (let i = 0; i < text.length; i++) {\n        bytes.push(text[i].charCodeAt(0));\n    }\n    return bytes;\n};\nexport default asciiToBytes;\n//# sourceMappingURL=asciiToBytes.js.map","/**\n * Converts bytes containing ASCII-UTF8 characters data to ASCII format itself\n * @param bytes bytes containing the data\n *\n * Check example here: https://gist.github.com/eyecatchup/6742657\n */\nconst bytesToAscii = (bytes) => {\n    return bytes.map((byte) => String.fromCharCode(byte)).join('');\n};\nexport default bytesToAscii;\n//# sourceMappingURL=bytesToAscii.js.map","import Header from './utils/Header';\nimport EncodedOutput from './utils/EncodedOutput';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nimport asciiToBytes from '../core/asciiToBytes';\nimport bytesToAscii from '../core/bytesToAscii';\nclass ASCIIText {\n    /**\n     * ASCIIText Loader - encoder and decoder. You can use it for handle with\n     * ascii characters.\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     */\n    constructor() {\n        this.header = new Header(loadersTypeId.ASCII_TEXT);\n    }\n    /**\n     * Converts ASCII-UTF8 text to bits\n     * @param text ASCII text format (UTF8)\n     */\n    encode(text) {\n        let asciiByteArray = asciiToBytes(text);\n        return new EncodedOutput(this.header, asciiByteArray);\n    }\n    /**\n     * Converts bytes containing ASCII-UTF8 characters data to ASCII format itself\n     * @param bytes bytes containing the data\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by ASCIIText loader.');\n        }\n        // ASCII byte array\n        const asciiDataByteArray = [];\n        bytes.slice(1).forEach((byte) => asciiDataByteArray.push(byte));\n        return bytesToAscii(asciiDataByteArray);\n    }\n    /**\n     * Get only sample data from bytes. Bytes must be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        return bytes.slice(TYPE_ID_BYTE_SIZE);\n    }\n    decodeChunk() { }\n}\nexport default ASCIIText;\n//# sourceMappingURL=ASCIIText.js.map","import binaryToDecimal from './binaryToDecimal';\nconst MAX_HEX = 255;\n/**\n * Convert the hex value (0 - 255) to fit the desired bits e.g 2, 4, 8\n * @param currentDecimalHexColor Hex value 0 - 255\n * @param maxBitsToStore Bits to store this data 2, 4, 8\n */\nconst hexToBpp = (currentDecimalHexColor, maxBitsToStore) => {\n    const maxBits = Array(maxBitsToStore).fill('1').join('');\n    const bitsMaxSuportedValue = binaryToDecimal(maxBits);\n    const per = (currentDecimalHexColor * 100) / MAX_HEX;\n    return Math.round((per * bitsMaxSuportedValue) / 100);\n};\nexport default hexToBpp;\n//# sourceMappingURL=hexToBpp.js.map","import bmp from 'bmp-js';\nimport { DEFAULT_BITS_DEPTH } from '../constants';\nimport EncodedOutput from '../loaders/utils/EncodedOutput';\nimport sliceTextInChunks from './sliceTextInChunks';\nimport decimalToBinary from './decimalToBinary';\nimport binaryToDecimal from './binaryToDecimal';\nimport hexToBpp from './hexToBpp';\nimport numberToUint8 from './numberToUint8';\n/**\n * Encodes bitmap data using any bit depth less than 8 bits\n *\n * @param imageBuffer 24 bits Bitmap buffer\n */\nconst encodeBitmapPerPixel = (imageBuffer, header, bitsPerPixel) => {\n    const bmpData = bmp.decode(imageBuffer);\n    const { width, height } = bmpData;\n    // Header\n    const widthBits = numberToUint8(width, 2); // 2 bytes\n    const heightBits = numberToUint8(height, 2); // 2 bytes\n    header.addBytes(widthBits);\n    header.addBytes(heightBits);\n    // Get image pixels buffer\n    const imageData = bmpData.getData();\n    const bitmapByteArray = [];\n    // Shold store complete byte (8 bits).\n    // before of it be stored.\n    let colorBits = '';\n    // Stores only the red as factor to grey scale\n    for (let y = 3; y < imageData.length; y += 4) {\n        colorBits += decimalToBinary(hexToBpp(imageData.readUInt8(y), bitsPerPixel), bitsPerPixel);\n    }\n    // Converts each 8 bits to decimal value to be stored\n    const colorBytes = sliceTextInChunks(colorBits, DEFAULT_BITS_DEPTH, '', true, '0');\n    colorBytes.forEach((byteInBits) => {\n        bitmapByteArray.push(binaryToDecimal(byteInBits));\n    });\n    return new EncodedOutput(header, bitmapByteArray);\n};\nexport default encodeBitmapPerPixel;\n//# sourceMappingURL=encodeBitmapPerPixel.js.map","import Header from './utils/Header';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nimport encodeBitmapPerPixel from '../core/encodeBitmapPerPixel';\nimport decodeBitmapPerPixel from '../core/decodeBitmapPerPixel';\nimport decimalToBinary from '../core/decimalToBinary';\nimport sliceTextInChunks from '../core/sliceTextInChunks';\nimport bppToHex from '../core/bppToHex';\nimport binaryToDecimal from '../core/binaryToDecimal';\nclass Bitmap2bitspp {\n    /**\n     * Bitmap2bitspp Loader - encoder and decoder. This will take only 1 byte of color and\n     * generate a bitmap with 24 bytes containing the gray factor. The encoded\n     * data will store only 2 bits per pixel.\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     * width: 2 bytes\n     * height: 2 bytes\n     * imageBits: infinity (the rest of bits)\n     */\n    constructor() {\n        this.BPP = 2;\n        this.header = new Header(loadersTypeId.BITMAP_2BITS_PP);\n        this.position = 0;\n        this.groupPosition = 0;\n    }\n    /**\n     * Get a 24 bits bitmap and converts it to 2 bits per pixel (4 grey tons)\n     * format and generates the bits to be stored on audio.\n     *\n     * @param imageBuffer 24 bits Bitmap buffer\n     */\n    encode(imageBuffer) {\n        return encodeBitmapPerPixel(imageBuffer, this.header, this.BPP);\n    }\n    /**\n     * Decodes the Bitmap information and return a Bitmap 2 bits per pixel buffer (4 tons of grey).\n     * However, the final decoded file will be a 24 Bitmap file.\n     * @param bytes bytes containing the data\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by Bitmap4bitspp loader.');\n        }\n        return decodeBitmapPerPixel(bytes, this.BPP);\n    }\n    /**\n     * Get only sample data from bytes. Bytes can be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        return bytes.slice(headerBitsSize);\n    }\n    /**\n     * Process every file bytes and converts each value to an RGBA (integers in the range 0 to 255) that'll\n     * be put into a slot of a imageData (Uint8ClampedArray). Each 4 slots represents an RGBA pixel.\n     *\n     * @param data one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. This is provided by a Canvas context.\n     * @param imageData Bitmap wav data\n     * @param bytesChunk The amount of bytes that must be read in this cycle\n     */\n    decodeChunk({ data, imageData, bytesChunk }) {\n        for (let i = 0; i < bytesChunk; i++) {\n            const imageDataPixelsInfo = imageData[this.position];\n            const imageDataGroup = sliceTextInChunks(decimalToBinary(imageDataPixelsInfo), this.BPP);\n            for (let d = 0; d < imageDataGroup.length; d++) {\n                const colorFactor = bppToHex(binaryToDecimal(imageDataGroup[d]), this.BPP);\n                data[this.groupPosition * 4] = colorFactor;\n                data[this.groupPosition * 4 + 1] = colorFactor;\n                data[this.groupPosition * 4 + 2] = colorFactor;\n                data[this.groupPosition * 4 + 3] = 255;\n                this.groupPosition++;\n            }\n            this.position++;\n        }\n    }\n}\nexport default Bitmap2bitspp;\n//# sourceMappingURL=Bitmap2bitspp.js.map","import Header from './utils/Header';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nimport encodeBitmapPerPixel from '../core/encodeBitmapPerPixel';\nimport decodeBitmapPerPixel from '../core/decodeBitmapPerPixel';\nimport decimalToBinary from '../core/decimalToBinary';\nimport sliceTextInChunks from '../core/sliceTextInChunks';\nimport bppToHex from '../core/bppToHex';\nimport binaryToDecimal from '../core/binaryToDecimal';\nclass Bitmap4bitspp {\n    /**\n     * Bitmap4bitspp Loader - encoder and decoder. This will take only 1 byte of color and\n     * generate a bitmap with 24 bytes containing the gray factor. The encoded\n     * data will store only 4 bits per pixel.\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     * width: 2 bytes\n     * height: 2 bytes\n     * imageBits: infinity (the rest of bits)\n     */\n    constructor() {\n        this.BPP = 4;\n        this.header = new Header(loadersTypeId.BITMAP_4BITS_PP);\n        this.position = 0;\n        this.groupPosition = 0;\n    }\n    /**\n     * Get a 24 bits bitmap and converts it to 4 bits per pixel (16 grey tons)\n     * format and generates the bits to be stored on audio.\n     *\n     * @param imageBuffer 24 bits Bitmap buffer\n     */\n    encode(imageBuffer) {\n        return encodeBitmapPerPixel(imageBuffer, this.header, this.BPP);\n    }\n    /**\n     * Decodes the Bitmap information and return a Bitmap 4 bits per pixel buffer (16 tons of grey).\n     * However, the final decoded file will be a 24 Bitmap file.\n     * @param bytes bytes containing the data\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by Bitmap4bitspp loader.');\n        }\n        return decodeBitmapPerPixel(bytes, this.BPP);\n    }\n    /**\n     * Get only sample data from bytes. Bytes can be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        return bytes.slice(headerBitsSize);\n    }\n    /**\n     * Process every file bytes and converts each value to an RGBA (integers in the range 0 to 255) that'll\n     * be put into a slot of a imageData (Uint8ClampedArray). Each 4 slots represents an RGBA pixel.\n     *\n     * @param data one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. This is provided by a Canvas context.\n     * @param imageData Bitmap wav data\n     * @param bytesChunk The amount of bytes that must be read in this cycle\n     */\n    decodeChunk({ data, imageData, bytesChunk }) {\n        for (let i = 0; i < bytesChunk; i++) {\n            const imageDataPixelsInfo = imageData[this.position];\n            const imageDataGroup = sliceTextInChunks(decimalToBinary(imageDataPixelsInfo), this.BPP);\n            for (let d = 0; d < imageDataGroup.length; d++) {\n                const colorFactor = bppToHex(binaryToDecimal(imageDataGroup[d]), this.BPP);\n                data[this.groupPosition * 4] = colorFactor;\n                data[this.groupPosition * 4 + 1] = colorFactor;\n                data[this.groupPosition * 4 + 2] = colorFactor;\n                data[this.groupPosition * 4 + 3] = 255;\n                this.groupPosition++;\n            }\n            this.position++;\n        }\n    }\n}\nexport default Bitmap4bitspp;\n//# sourceMappingURL=Bitmap4bitspp.js.map","import Header from './utils/Header';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nimport encodeBitmapPerPixel from '../core/encodeBitmapPerPixel';\nimport decodeBitmapPerPixel from '../core/decodeBitmapPerPixel';\nimport decimalToBinary from '../core/decimalToBinary';\nimport sliceTextInChunks from '../core/sliceTextInChunks';\nimport bppToHex from '../core/bppToHex';\nimport binaryToDecimal from '../core/binaryToDecimal';\nclass Bitmap1bitpp {\n    /**\n     * Bitmap1bitpp Loader - encoder and decoder. This will take only 1 byte of color and\n     * generate a bitmap with 24 bytes containing the gray factor. The encoded\n     * data will store only 1 bit per pixel.\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     * width: 2 bytes\n     * height: 2 bytes\n     * imageBits: infinity (the rest of bits)\n     */\n    constructor() {\n        this.BPP = 1;\n        this.header = new Header(loadersTypeId.BITMAP_1BIT_PP);\n        this.position = 0;\n        this.groupPosition = 0;\n    }\n    /**\n     * Get a 24 bits bitmap and converts it to 1 bit per pixel (black and white)\n     * format and generates the bits to be stored on audio.\n     *\n     * @param imageBuffer 24 bits Bitmap buffer\n     */\n    encode(imageBuffer) {\n        return encodeBitmapPerPixel(imageBuffer, this.header, this.BPP);\n    }\n    /**\n     * Decodes the Bitmap information and return a Bitmap 1 bits per pixel buffer (black and white).\n     * However, the final decoded file will be a 24 Bitmap file.\n     * @param bytes bytes containing the data\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by Bitmap1bitpp loader.');\n        }\n        return decodeBitmapPerPixel(bytes, this.BPP);\n    }\n    /**\n     * Get only sample data from bytes. Bytes can be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        return bytes.slice(headerBitsSize);\n    }\n    /**\n     * Process every file bytes and converts each value to an RGBA (integers in the range 0 to 255) that'll\n     * be put into a slot of a imageData (Uint8ClampedArray). Each 4 slots represents an RGBA pixel.\n     *\n     * @param data one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. This is provided by a Canvas context.\n     * @param imageData Bitmap wav data\n     * @param bytesChunk The amount of bytes that must be read in this cycle\n     */\n    decodeChunk({ data, imageData, bytesChunk }) {\n        for (let i = 0; i < bytesChunk; i++) {\n            const imageDataPixelsInfo = imageData[this.position];\n            const imageDataGroup = sliceTextInChunks(decimalToBinary(imageDataPixelsInfo), this.BPP);\n            for (let d = 0; d < imageDataGroup.length; d++) {\n                const colorFactor = bppToHex(binaryToDecimal(imageDataGroup[d]), this.BPP);\n                data[this.groupPosition * 4] = colorFactor;\n                data[this.groupPosition * 4 + 1] = colorFactor;\n                data[this.groupPosition * 4 + 2] = colorFactor;\n                data[this.groupPosition * 4 + 3] = 255;\n                this.groupPosition++;\n            }\n            this.position++;\n        }\n    }\n}\nexport default Bitmap1bitpp;\n//# sourceMappingURL=Bitmap1bitpp.js.map","import Header from './utils/Header';\nimport EncodedOutput from './utils/EncodedOutput';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nimport numberToUint8 from '../core/numberToUint8';\nimport uint8ToNumber from '../core/uint8ToNumber';\nclass DecimalNumber {\n    /**\n     * DecimalNumber Loader - encoder and decoder. You can use it for handle with\n     * decimal numbers (the common numbers we know as a human).\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     */\n    constructor() {\n        this.header = new Header(loadersTypeId.DECIMAL_NUMBER);\n    }\n    /**\n     * Encodes decimal number\n     *\n     * @param {number} numberValue decimal number value\n     * @returns {string}\n     */\n    encode(numberValue) {\n        const uint8Number = numberToUint8(numberValue);\n        return new EncodedOutput(this.header, uint8Number);\n    }\n    /**\n     * Converts bits containing decimal number data to decimal itself\n     * @param bytes bytes containing the data with decimal number\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by ASCIIText loader.');\n        }\n        // Decimal byte array\n        const decimalDataByteArray = [];\n        bytes.slice(1).forEach((byte) => decimalDataByteArray.push(byte));\n        return uint8ToNumber(decimalDataByteArray);\n    }\n    /**\n     * Get only sample data from bytes. Bytes must be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        return bytes.slice(TYPE_ID_BYTE_SIZE);\n    }\n    decodeChunk() { }\n}\nexport default DecimalNumber;\n//# sourceMappingURL=DecimalNumber.js.map","import { loadersTypeId } from '../constants';\nimport { DecimalNumber, ASCIIText, Bitmap24bitsTrueColor, Bitmap1bitpp, Bitmap2bitspp, Bitmap4bitspp, Bitmap8bitspp, } from '../loaders';\n/**\n * Get Loader by its typeId\n * @param loaderTypeId\n */\nexport default function getLoaderByTypeId(loaderTypeId) {\n    switch (loaderTypeId) {\n        case loadersTypeId.DECIMAL_NUMBER:\n            return new DecimalNumber();\n        case loadersTypeId.ASCII_TEXT:\n            return new ASCIIText();\n        case loadersTypeId.BITMAP:\n            return new Bitmap24bitsTrueColor();\n        case loadersTypeId.BITMAP_1BIT_PP:\n            return new Bitmap1bitpp();\n        case loadersTypeId.BITMAP_2BITS_PP:\n            return new Bitmap2bitspp();\n        case loadersTypeId.BITMAP_4BITS_PP:\n            return new Bitmap4bitspp();\n        case loadersTypeId.BITMAP_8BITS_PP:\n            return new Bitmap8bitspp();\n        default:\n            return null;\n    }\n}\n//# sourceMappingURL=getLoaderByTypeId.js.map","import bmp from 'bmp-js';\nimport { TYPE_ID_BYTE_SIZE, DEFAULT_BITS_DEPTH } from '../constants';\nimport sliceTextInChunks from './sliceTextInChunks';\nimport decimalToBinary from './decimalToBinary';\nimport binaryToDecimal from './binaryToDecimal';\nimport bppToHex from './bppToHex';\nimport uint8ToNumber from './uint8ToNumber';\n/**\n * Decodes bitmap data using any bit depth less than 8 bits\n * @param bytes bytes containing the data\n */\nconst decodeBitmapPerPixel = (bytes, bitsPerPixel) => {\n    const additionalHeaderBytes = 4;\n    const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBytes;\n    let output;\n    let width; // 2 bytes\n    let height; // 2 bytes\n    let imageBits = ''; // Rest of Bits\n    // Read after have enough bytes loaded to read the header bytes\n    if (bytes.length >= headerBitsSize) {\n        width = uint8ToNumber([bytes[1], bytes[2]]);\n        height = uint8ToNumber([bytes[3], bytes[4]]);\n        // Transform byte to bits\n        bytes\n            .slice(headerBitsSize)\n            .forEach((byte) => (imageBits += decimalToBinary(byte, DEFAULT_BITS_DEPTH)));\n        // Get group bits\n        const imageDataBitsArray = sliceTextInChunks(imageBits, bitsPerPixel);\n        // Add the QUAD bits and BLUE, GREEN and RED as the factor saved on the encode\n        const imageDataWithQBGR = [];\n        for (let y = 0; y < imageDataBitsArray.length; y++) {\n            // The fusion of these data will generate gray scale according\n            // to the factor registered on imageDataBitsArray[y]\n            const color = bppToHex(binaryToDecimal(imageDataBitsArray[y]), bitsPerPixel);\n            imageDataWithQBGR.push(0, // QUAD\n            color, // BLUE\n            color, // GREEN\n            color // RED\n            );\n        }\n        const bmpData = {\n            data: Buffer.from(imageDataWithQBGR),\n            width,\n            height,\n        };\n        const rawData = bmp.encode(bmpData);\n        output = rawData.data;\n    }\n    else {\n        output = Buffer.alloc(0);\n    }\n    return output;\n};\nexport default decodeBitmapPerPixel;\n//# sourceMappingURL=decodeBitmapPerPixel.js.map","export const BMP_CONTENT_TYPE = 'image/bmp';\nexport const WAV_CONTENT_TYPE = 'audio/wav';\nexport const TEXT_CONTENT_TYPE = 'text/plain';\nexport const DECIMAL_CONTENT_TYPE = TEXT_CONTENT_TYPE;\n\ntype ContentTypes =\n  | typeof BMP_CONTENT_TYPE\n  | typeof WAV_CONTENT_TYPE\n  | typeof TEXT_CONTENT_TYPE\n  | typeof DECIMAL_CONTENT_TYPE;\n\nconst saveFile = (\n  buffer: Buffer,\n  filename: string,\n  contentType: ContentTypes\n) => {\n  const a = document.createElement('a');\n  const blob = new Blob(\n    [new Uint8Array(buffer, buffer.byteOffset, buffer.length)],\n    { type: contentType }\n  );\n  a.href = window.URL.createObjectURL(blob);\n  a.download = filename;\n  a.click();\n};\n\nexport default saveFile;\n","import { bitmapTypeIds } from 'voyager-edsound/lib/constants';\nimport { getLoaderByTypeId, Loader } from 'voyager-edsound/lib/helpers';\nimport getBytesFromBuffer from 'voyager-edsound/lib/core/getBytesFromBuffer';\nimport saveFile, { BMP_CONTENT_TYPE } from '../saveFile';\n\nlet handlerOnDecodeFinished = () => {};\n/**\n * On decode finished handler. This method will be dispatched when the process of decoding\n * is finished.\n */\nexport const onDecodeFinished = (handler: () => void) => {\n  handlerOnDecodeFinished = handler;\n};\n\n/**\n * Clear stage (bitmap visualizer)\n */\nexport const clearStage = () => {\n  if (stageContext != null) {\n    stageContext.clearRect(0, 0, canvasWidth, canvasHeight);\n  }\n};\n\nlet stageContext: CanvasRenderingContext2D;\nlet canvasWidth: number;\nlet canvasHeight: number;\nlet imageData: ImageData;\nlet data: Uint8ClampedArray;\nlet currentFileBytes: Uint8Array;\nlet currentFileSampleData: Uint8Array;\n\n/**\n * Init the stage canvas. It must be ready to render bitmap info extracted from audio\n * @param stageCanvas\n */\nfunction initStageProcess(stageCanvas: HTMLCanvasElement) {\n  stageContext = stageCanvas.getContext('2d') || new CanvasRenderingContext2D();\n  canvasWidth = stageCanvas.width;\n  canvasHeight = stageCanvas.height;\n\n  stageContext.clearRect(0, 0, canvasWidth, canvasHeight);\n  imageData = stageContext.getImageData(0, 0, canvasWidth, canvasHeight);\n  data = imageData.data;\n}\n\nlet previousAnimationId: number;\n/**\n * Init audio process canvas. Must be called after initStageProcess.\n * @param visualizerCanvas\n * @param audio\n */\nfunction initAudioProcess(\n  visualizerCanvas: HTMLCanvasElement,\n  audio: HTMLAudioElement\n) {\n  const bufferLength = analyser.frequencyBinCount;\n  const dataArray = new Uint8Array(bufferLength);\n\n  const WIDTH = visualizerCanvas.width;\n  const HEIGHT = visualizerCanvas.height;\n  const visualizerContext =\n    visualizerCanvas.getContext('2d') || new CanvasRenderingContext2D();\n\n  if (previousAnimationId != null) {\n    cancelAnimationFrame(previousAnimationId);\n  }\n\n  function renderFrame() {\n    previousAnimationId = requestAnimationFrame(renderFrame);\n\n    analyser.getByteTimeDomainData(dataArray);\n    draw(audio.currentTime, audio.duration);\n\n    visualizerContext.fillStyle = '#000';\n    visualizerContext.fillRect(0, 0, WIDTH, HEIGHT);\n    visualizerContext.lineWidth = 1.4;\n    visualizerContext.strokeStyle = 'rgb(255, 255, 255)';\n    visualizerContext.beginPath();\n\n    let sliceWidth = (WIDTH * 1.0) / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      let v = dataArray[i] / 128.0;\n      let y = (v * HEIGHT) / 2;\n\n      if (i === 0) {\n        visualizerContext.moveTo(x, y);\n      } else {\n        visualizerContext.lineTo(x, y);\n      }\n\n      x += sliceWidth;\n    }\n\n    visualizerContext.lineTo(\n      visualizerCanvas.width,\n      visualizerCanvas.height / 2\n    );\n    visualizerContext.stroke();\n  }\n\n  audio.play();\n  renderFrame();\n}\n\nlet diff = 0;\n/**\n * Draw the visualizer according to the sound samples\n * @param currentTime\n * @param duration\n */\nfunction draw(currentTime: number, duration: number) {\n  if (currentFileSampleData != null) {\n    const percPlayed = (100 * currentTime) / duration;\n    const readBytes = Math.ceil(\n      (percPlayed * currentFileSampleData.length) / 100\n    );\n    const finalAdd = readBytes - diff;\n    diff = readBytes;\n\n    if (!isNaN(finalAdd)) {\n      if (loader != null && loader.decodeChunk != null) {\n        loader.decodeChunk({\n          totalSamplesSize: currentFileSampleData.length,\n          data,\n          imageData: currentFileSampleData,\n          bytesChunk: finalAdd,\n        });\n      }\n\n      stageContext.putImageData(imageData, 0, 0);\n    }\n  }\n}\n\nconst fileReader = new FileReader();\nlet loader: Loader;\nlet processInitialized = false;\nlet audioContext: AudioContext;\nlet source: MediaElementAudioSourceNode;\nlet analyser: AnalyserNode;\n/**\n * Init the audio decoding process and render visualizer and data according to typeId\n * @param visualizerCanvas\n * @param stageCanvas\n * @param audio\n * @param file\n * @param typeId\n */\nexport const processSound = async (\n  visualizerCanvas: HTMLCanvasElement,\n  stageCanvas: HTMLCanvasElement,\n  audio: HTMLAudioElement,\n  file: File\n) => {\n  if (!processInitialized) {\n    processInitialized = true;\n\n    audioContext = new AudioContext();\n    source = audioContext.createMediaElementSource(audio);\n\n    // Analyser\n    analyser = audioContext.createAnalyser();\n    source.connect(analyser);\n    analyser.connect(audioContext.destination);\n    analyser.fftSize = 4096 / 2;\n\n    // Events\n    audio.onended = () => {\n      handlerOnDecodeFinished();\n      setTimeout(() => {\n        cancelAnimationFrame(previousAnimationId);\n        previousAnimationId = NaN;\n      }, 200);\n    };\n\n    fileReader.onload = () => {\n      // Load file bytes (without wav header)\n      currentFileBytes = getBytesFromBuffer(\n        Buffer.from(fileReader.result as ArrayBuffer)\n      );\n      // Get typeId.\n      const fileTypeId = currentFileBytes[0];\n      // Initialize the recomended Loader to decode audio data\n      loader = getLoaderByTypeId(fileTypeId);\n      if (loader != null) {\n        // Set data (extracted from samples). This will return only samples without wav header and loader header\n        currentFileSampleData = loader.getSampleData(currentFileBytes);\n      }\n\n      // Audio Process\n      initAudioProcess(visualizerCanvas, audio);\n    };\n  }\n  fileReader.readAsArrayBuffer(file);\n\n  // Set audio source\n  audio.src = URL.createObjectURL(file);\n\n  // Stage Process\n  initStageProcess(stageCanvas);\n};\n\n/**\n * Open dialog for save decoded file\n */\nexport const saveDecodedFile = async () => {\n  // If the content is bitmap\n  if (\n    loader != null &&\n    bitmapTypeIds.indexOf(loader.header.getHeaderTypeId()) !== -1\n  ) {\n    saveFile(\n      loader.decode(currentFileBytes) as Buffer,\n      'image',\n      BMP_CONTENT_TYPE\n    );\n  }\n};\n","import { WAV_HEADER_BYTES_SIZE } from '../constants';\n/**\n * Get typeId of a wav buffer\n * @param audioBuffer\n */\nconst getTypeIdFromBuffer = (audioBuffer) => {\n    //Ignore WAV header - 44 bytes\n    const sampleDataBuffer = Buffer.alloc(1);\n    audioBuffer.copy(sampleDataBuffer, 0, WAV_HEADER_BYTES_SIZE, WAV_HEADER_BYTES_SIZE + 1);\n    return sampleDataBuffer.readUInt8(0);\n};\nexport default getTypeIdFromBuffer;\n//# sourceMappingURL=getTypeIdFromBuffer.js.map","import { WAV_HEADER_BYTES_SIZE } from '../constants';\nimport uint8ToNumber from '../core/uint8ToNumber';\n/**\n * Get bitmap header information from wav sampleData. You need to know the typeId before in order\n * to be sure the buffer belongs to a Bitmap loader format. Use getTypeIdFromBuffer to get that (typeId).\n * @param audioBuffer Audio file buffer\n */\nconst getBitmapHeaderInfo = (audioBuffer) => {\n    //Ignore WAV header - 44 bytes and get the 5 bytes necessary to read Wav Bitmap Loader Header information\n    const sampleDataBuffer = Buffer.alloc(5);\n    audioBuffer.copy(sampleDataBuffer, 0, WAV_HEADER_BYTES_SIZE, WAV_HEADER_BYTES_SIZE + 5);\n    return {\n        typeId: sampleDataBuffer.readUInt8(0),\n        width: uint8ToNumber([\n            sampleDataBuffer.readUInt8(1),\n            sampleDataBuffer.readUInt8(2),\n        ]),\n        height: uint8ToNumber([\n            sampleDataBuffer.readUInt8(3),\n            sampleDataBuffer.readUInt8(4),\n        ]),\n    };\n};\nexport default getBitmapHeaderInfo;\n//# sourceMappingURL=getBitmapHeaderInfo.js.map","import bmp from 'bmp-js';\nimport Header from './utils/Header';\nimport EncodedOutput from './utils/EncodedOutput';\nimport numberToUint8 from '../core/numberToUint8';\nimport uint8ToNumber from '../core/uint8ToNumber';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nclass Bitmap24bitsTrueColor {\n    /**\n     * Bitmap 24bits True Color Loader - encoder and decoder.\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     * width: 2 bytes\n     * height: 2 bytes\n     * imageBits: infinity (the rest of bits)\n     */\n    constructor() {\n        this.header = new Header(loadersTypeId.BITMAP);\n        this.position = 0;\n    }\n    /**\n     * Get a 24 bits bitmap and converts it to 24 bits per pixel (RGB color, ignoring alpha)\n     * format and generates the bits to be stored on audio.\n     *\n     * @param imageBuffer 24 bits Bitmap buffer\n     */\n    encode(imageBuffer) {\n        const bmpData = bmp.decode(imageBuffer);\n        const { width, height } = bmpData;\n        // Header\n        const widthBits = numberToUint8(width, 2); // 2 bytes\n        const heightBits = numberToUint8(height, 2); // 2 bits\n        this.header.addBytes(widthBits);\n        this.header.addBytes(heightBits);\n        const redSamples = [];\n        const greenSamples = [];\n        const blueSamples = [];\n        // Get image pixels buffer\n        const imageData = bmpData.getData();\n        for (let y = 3; y < imageData.length; y += 4) {\n            blueSamples.push(imageData.readUInt8(y - 2));\n            greenSamples.push(imageData.readUInt8(y - 1));\n            redSamples.push(imageData.readUInt8(y));\n        }\n        return new EncodedOutput(this.header, blueSamples.concat(greenSamples, redSamples));\n    }\n    /**\n     * Decodes the Bitmap information and return a Bitmap 24 bits per pixel buffer (RGB color).\n     * However, the final decoded file will be a 24 Bitmap file.\n     * @param bytes bytes containing the data\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by Bitmap24bitsTrueColor loader.');\n        }\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        let output;\n        let width; // 2 bytes\n        let height; // 2 bytes\n        // Read after have enough bytes loaded to read the header bytes\n        if (bytes.length >= headerBitsSize) {\n            width = uint8ToNumber([bytes[1], bytes[2]]);\n            height = uint8ToNumber([bytes[3], bytes[4]]);\n            // Bitmap byte array\n            const bitmapDataByteArray = [];\n            const imageBytes = bytes.slice(headerBitsSize);\n            const colorSamplesSize = imageBytes.length / 3; // (RGB)\n            for (let y = 0; y < colorSamplesSize; y++) {\n                // QUAD, BLUE, GREEN, RED (QBGR)\n                bitmapDataByteArray.push(0, imageBytes[y], imageBytes[y + colorSamplesSize], imageBytes[y + colorSamplesSize * 2]);\n            }\n            const bmpData = {\n                data: Buffer.from(bitmapDataByteArray),\n                width,\n                height,\n            };\n            const rawData = bmp.encode(bmpData);\n            output = rawData.data;\n        }\n        else {\n            output = Buffer.alloc(0);\n        }\n        return output;\n    }\n    /**\n     * Get only sample data from bytes. Bytes can be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        return bytes.slice(headerBitsSize);\n    }\n    /**\n     * Process every file bytes and converts each value to an RGBA (integers in the range 0 to 255) that'll\n     * be put into a slot of a imageData (Uint8ClampedArray). Each 4 slots represents an RGBA pixel.\n     *\n     * @param totalSamplesSize Sample bytes length (bytes data without wav header and loader header)\n     * @param data one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. This is provided by a Canvas context.\n     * @param imageBuffer Bitmap wav data\n     * @param bytesChunk The amount of bytes that must be read in this cycle\n     */\n    decodeChunk({ totalSamplesSize, data, imageData, bytesChunk, }) {\n        const colorSamplesSize = totalSamplesSize / 3;\n        for (let y = 0; y < bytesChunk; y++) {\n            // BLUE, GREEN, RED (BGR) - The same way this bitmap is encoded\n            if (this.position <= colorSamplesSize) {\n                data[this.position * 4 + 2] = imageData[this.position]; // Blue -\n                data[this.position * 4 + 3] = 255;\n            }\n            else if (this.position > colorSamplesSize &&\n                this.position <= colorSamplesSize * 2) {\n                data[this.position * 4 + 1 - colorSamplesSize * 4] =\n                    imageData[this.position]; // Green -\n            }\n            else if (this.position > colorSamplesSize * 2 &&\n                this.position <= colorSamplesSize * 3) {\n                data[this.position * 4 - colorSamplesSize * 2 * 4] =\n                    imageData[this.position]; // Red -\n            }\n            this.position++;\n        }\n    }\n}\nexport default Bitmap24bitsTrueColor;\n//# sourceMappingURL=Bitmap24bitsTrueColor.js.map","import bmp from 'bmp-js';\nimport Header from './utils/Header';\nimport EncodedOutput from './utils/EncodedOutput';\nimport { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';\nimport numberToUint8 from '../core/numberToUint8';\nimport uint8ToNumber from '../core/uint8ToNumber';\nclass Bitmap8bitspp {\n    /**\n     * Bitmap8bitspp Loader - encoder and decoder. This will take only 1 byte of color and\n     * generate a bitmap with 24 bytes containing the gray factor. The encoded\n     * data will store only 8 bits per pixel.\n     *\n     * The header is storing one parameter:\n     * typeId: 1 byte\n     * width: 2 bytes\n     * height: 2 bytes\n     * imageBits: infinity (the rest of bits)\n     */\n    constructor() {\n        this.header = new Header(loadersTypeId.BITMAP_8BITS_PP);\n        this.position = 0;\n    }\n    /**\n     * Get a 24 bits bitmap and converts its to 8 bits per pixel (256 grey tons) format and\n     * generates the bits to be stored on audio.\n     *\n     * @param imageBuffer 24 bits Bitmap buffer\n     */\n    encode(imageBuffer) {\n        const bmpData = bmp.decode(imageBuffer);\n        const { width, height } = bmpData;\n        // Header\n        const widthBits = numberToUint8(width, 2); // 2 bytes\n        const heightBits = numberToUint8(height, 2); // 2 bits\n        this.header.addBytes(widthBits);\n        this.header.addBytes(heightBits);\n        // Get image pixels buffer\n        const imageData = bmpData.getData();\n        let bitmapByteArray = [];\n        // Stores only the red as factor to grey scale\n        for (let y = 3; y < imageData.length; y += 4) {\n            bitmapByteArray.push(imageData.readUInt8(y));\n        }\n        return new EncodedOutput(this.header, bitmapByteArray);\n    }\n    /**\n     * Decodes the Bitmap information getting a Bitmap 8 bits per pixel buffer (256 grey tons).\n     * However, the final decoded file will be a 24 Bitmap file.\n     * @param bytes bytes containing the data\n     */\n    decode(bytes) {\n        // Check typeId\n        const typeId = bytes[0];\n        if (typeId !== this.header.getHeaderTypeId()) {\n            throw new Error('This is not a audio file generated by Bitmap8bitspp loader.');\n        }\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        let output;\n        let width; // 2 bytes\n        let height; // 2 bytes\n        // Read after have enough bytes loaded to read the header bytes\n        if (bytes.length >= headerBitsSize) {\n            width = uint8ToNumber([bytes[1], bytes[2]]);\n            height = uint8ToNumber([bytes[3], bytes[4]]);\n            // Bitmap byte array\n            const bitmapDataByteArray = [];\n            // Generate bitmap buffer following the way below\n            bytes.slice(headerBitsSize).forEach((byte) => {\n                // QUAD, BLUE, GREEN, RED (QBGR)\n                bitmapDataByteArray.push(0, byte, byte, byte);\n            });\n            const bmpData = {\n                data: Buffer.from(bitmapDataByteArray),\n                width,\n                height,\n            };\n            const rawData = bmp.encode(bmpData);\n            output = rawData.data;\n        }\n        else {\n            output = Buffer.alloc(0);\n        }\n        return output;\n    }\n    /**\n     * Get only sample data from bytes. Bytes can be delivered by Reader\n     * @param bytes bytes containing the data\n     */\n    getSampleData(bytes) {\n        const additionalHeaderBits = 4;\n        const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;\n        return bytes.slice(headerBitsSize);\n    }\n    /**\n     * Process every file bytes and converts each value to an RGBA (integers in the range 0 to 255) that'll\n     * be put into a slot of a imageData (Uint8ClampedArray). Each 4 slots represents an RGBA pixel.\n     *\n     * @param data one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. This is provided by a Canvas context.\n     * @param imageData Bitmap wav data\n     * @param bytesChunk The amount of bytes that must be read in this cycle\n     */\n    decodeChunk({ data, imageData, bytesChunk }) {\n        for (let i = 0; i < bytesChunk; i++) {\n            data[this.position * 4] = imageData[this.position];\n            data[this.position * 4 + 1] = imageData[this.position];\n            data[this.position * 4 + 2] = imageData[this.position];\n            data[this.position * 4 + 3] = 255;\n            this.position++;\n        }\n    }\n}\nexport default Bitmap8bitspp;\n//# sourceMappingURL=Bitmap8bitspp.js.map","import { WAV_HEADER_BYTES_SIZE, TYPE_ID_BYTE_SIZE } from '../constants';\n/**\n * Reads bytes located into the buffer and return it.\n * @param audioBuffer Buffer that will be decoded to obtain the bits\n * @param ignoreHeaderBytes Should read bytes ignoring the basic header bits. The header bits is where\n * basic data is stored like loader typeId. If you are reading a file wrote using some Header of this\n * software, you can set this as 'true', but, if you want just read a file containing only bytes without\n * a header, you should set this as 'false' (default).\n */\nconst getBytesFromBuffer = (audioBuffer, ignoreHeaderBytes = false) => {\n    //Ignore WAV header - 44 bytes\n    const ignoreLengthSize = ignoreHeaderBytes\n        ? WAV_HEADER_BYTES_SIZE + TYPE_ID_BYTE_SIZE\n        : WAV_HEADER_BYTES_SIZE;\n    const sampleDataBuffer = Buffer.alloc(audioBuffer.byteLength - ignoreLengthSize);\n    audioBuffer.copy(sampleDataBuffer, 0, ignoreLengthSize);\n    return Uint8Array.from(sampleDataBuffer);\n};\nexport default getBytesFromBuffer;\n//# sourceMappingURL=getBytesFromBuffer.js.map","let fileReader = new FileReader();\n\nconst fileToBuffer = (file: File) => {\n  return new Promise<Buffer>((resolve) => {\n    fileReader.onload = () => {\n      const arrayBuffer = fileReader.result as ArrayBuffer;\n      resolve(Buffer.from(arrayBuffer));\n    };\n\n    fileReader.readAsArrayBuffer(file);\n  });\n};\n\nexport default fileToBuffer;\n","import React from 'react';\nimport { Icon, Navbar, Button, H4 } from '@blueprintjs/core';\nimport { getLoaderByTypeId, Loader } from 'voyager-edsound/lib/helpers';\nimport { loadersTypeId } from 'voyager-edsound/lib/constants';\nimport writeSampleBytes from 'voyager-edsound/lib/core/writeSampleBytes';\nimport uint8ArrayToArray from 'helpers/uint8arrayToArray';\nimport imageToBitmap from 'helpers/imageToBitmap';\nimport saveFile, { WAV_CONTENT_TYPE } from 'helpers/saveFile';\n\nimport previewImage from '../../assets/images/image_preview.jpg';\nimport {\n  Container,\n  Paragraph,\n  ImageDetailWrapper,\n  ImageDetail,\n  PreviewImage,\n  FileStatus,\n} from './styles';\n\ninterface Props {\n  file: File;\n}\n\ntype BitmapLoaders =\n  | typeof loadersTypeId.BITMAP\n  | typeof loadersTypeId.BITMAP_1BIT_PP\n  | typeof loadersTypeId.BITMAP_2BITS_PP\n  | typeof loadersTypeId.BITMAP_4BITS_PP\n  | typeof loadersTypeId.BITMAP_8BITS_PP;\n\nconst fileReader = new FileReader();\n\nconst EncodeImageStatus: React.FC<Props> = ({ file }: Props) => {\n  const handlerEncodeImage = (\n    bitmapLoaderId: BitmapLoaders,\n    companionFileName: string\n  ) => {\n    fileReader.onload = async () => {\n      const fileBuffer = await imageToBitmap(\n        Buffer.from(fileReader.result as ArrayBuffer)\n      );\n\n      const bitmapLoader: Loader = getLoaderByTypeId(bitmapLoaderId);\n\n      if (bitmapLoader != null) {\n        const encodedData = bitmapLoader.encode(fileBuffer as never);\n        const encodedBuffer = await writeSampleBytes(\n          uint8ArrayToArray(encodedData.bytes)\n        );\n\n        saveFile(\n          encodedBuffer,\n          `${file.name}_${companionFileName}.wav`,\n          WAV_CONTENT_TYPE\n        );\n      }\n    };\n    fileReader.readAsArrayBuffer(file);\n  };\n\n  return (\n    <Container>\n      <FileStatus>\n        <Icon icon=\"media\" iconSize={24} color=\"rgba(167,182,194,.6)\" />\n        <H4 style={{ color: '#f5f8fa', marginLeft: 16 }}>{file.name}</H4>\n      </FileStatus>\n      <Paragraph>\n        <Icon icon=\"label\" iconSize={14} color=\"#f5f8fa\" /> {` `} Bpp means bits\n        per pixel\n      </Paragraph>\n      <Paragraph>\n        Below you can see an example of how the image will look like after be\n        decoded. Fewer bits means less file size but this impact directly to the\n        way the colours will be stored and read.\n      </Paragraph>\n      <Paragraph>\n        Click over Encode button according to the preferences you want:\n      </Paragraph>\n      <ImageDetailWrapper>\n        <ImageDetail>1 Bpp</ImageDetail>\n        <ImageDetail>2 Bpp</ImageDetail>\n        <ImageDetail>4 Bpp</ImageDetail>\n        <ImageDetail>8 Bpp</ImageDetail>\n        <ImageDetail>24 Bpp (RGB color)</ImageDetail>\n      </ImageDetailWrapper>\n      <PreviewImage src={previewImage} />\n      <Navbar className=\"bp3-dark\">\n        <Navbar.Group\n          style={{ float: 'none', justifyContent: 'space-between' }}\n        >\n          <Button\n            className=\"bp3-minimal\"\n            icon=\"document\"\n            text=\"Encode 1 Bpp\"\n            onClick={() => {\n              handlerEncodeImage(loadersTypeId.BITMAP_1BIT_PP, '1bpp');\n            }}\n          />\n          <Navbar.Divider />\n          <Button\n            className=\"bp3-minimal\"\n            icon=\"document\"\n            text=\"Encode 2 Bpp\"\n            onClick={() => {\n              handlerEncodeImage(loadersTypeId.BITMAP_2BITS_PP, '2bpp');\n            }}\n          />\n          <Navbar.Divider />\n          <Button\n            className=\"bp3-minimal\"\n            icon=\"document\"\n            text=\"Encode 4 Bpp\"\n            onClick={() => {\n              handlerEncodeImage(loadersTypeId.BITMAP_4BITS_PP, '4bpp');\n            }}\n          />\n          <Navbar.Divider />\n          <Button\n            className=\"bp3-minimal\"\n            icon=\"document\"\n            text=\"Encode 8 Bpp\"\n            onClick={() => {\n              handlerEncodeImage(loadersTypeId.BITMAP_8BITS_PP, '8bpp');\n            }}\n          />\n          <Navbar.Divider />\n          <Button\n            className=\"bp3-minimal\"\n            icon=\"document\"\n            text=\"Encode 24 Bpp\"\n            onClick={() => {\n              handlerEncodeImage(loadersTypeId.BITMAP, '24bppRGBColor');\n            }}\n          />\n        </Navbar.Group>\n      </Navbar>\n    </Container>\n  );\n};\n\nexport default EncodeImageStatus;\n","import WavEncoder from 'wav-encoder';\nimport { SAMPLE_BYTE, SAMPLE_RATE } from '../constants';\nconst writeSampleBytes = async (bytes) => {\n    const floatSampleDataMono = new Float32Array(bytes.length);\n    bytes.forEach((uint8Value, index) => {\n        // Using this formula avoid ther error caused by second formula\n        floatSampleDataMono[index] = SAMPLE_BYTE * uint8Value - 1;\n        // floatSampleDataMono[index] = (uint8Value - 128) / 128.0;\n    });\n    SAMPLE_RATE;\n    const audioData = {\n        sampleRate: SAMPLE_RATE,\n        channelData: [floatSampleDataMono],\n    };\n    const arrayBuffer = await WavEncoder.encode(audioData, { bitDepth: 8 });\n    return Buffer.from(arrayBuffer);\n};\nexport default writeSampleBytes;\n//# sourceMappingURL=writeSampleBytes.js.map","const uint8ArrayToArray = (uint8: Uint8Array) => {\n  const output: Array<number> = [];\n  uint8.forEach((byte) => {\n    output.push(byte);\n  });\n  return output;\n};\n\nexport default uint8ArrayToArray;\n","import Jimp from 'jimp';\nimport bmp from 'bmp-js';\n\nconst imageToBitmap = async (imageBuffer: Buffer) => {\n  const image = await Jimp.read(imageBuffer);\n\n  const QBGR: Array<number> = [];\n\n  const imageData = image.bitmap.data;\n  // Converts RGB to QBGR (way being used to voyager-edsound module)\n  for (let i = 3; i < imageData.length; i += 4) {\n    QBGR.push(\n      imageData.readUInt8(i),\n      imageData.readUInt8(i - 1),\n      imageData.readUInt8(i - 2),\n      imageData.readUInt8(i - 3)\n    );\n  }\n\n  return bmp.encode({\n    data: Buffer.from(QBGR),\n    width: image.bitmap.width,\n    height: image.bitmap.height,\n  }).data;\n};\n\nexport default imageToBitmap;\n","module.exports = __webpack_public_path__ + \"static/media/image_preview.d0db360c.jpg\";","module.exports = __webpack_public_path__ + \"static/media/app_icon.ecf81f5f.svg\";"],"sourceRoot":""}